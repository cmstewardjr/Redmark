<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Redmark</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Metal+Mania&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #100000; --surface-color: #1e1e1e; --text-color: #f0f0f0;
            --primary-color: #a00000; --primary-dark-color: #6e0000; --secondary-color: #2ecc40;
            --secondary-dark-color: #27ae60; --font-gothic: 'Metal Mania', cursive;
            /* New colors for vampires and player invincibility */
            --vampire-purple: #8A2BE2; /* Blue Violet */
            --vampire-orange: #FF8C00; /* Dark Orange */
            --cerulean-blue: #007BA7;
        }
        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; width: 100%; margin: 0; padding: 0; overflow: hidden; background-color: var(--bg-color); }
        #app-wrapper {
            display: flex;
            flex-direction: column;
            height: 100dvh;
            width: 100%;
            color: var(--text-color);
            font-family: var(--font-gothic);
            max-width: 1200px; /* Limits the maximum width of the content area */
            margin: 0 auto;    /* Centers the wrapper horizontally on wide screens */
        }
        h1 {
            color: var(--primary-color); font-family: var(--font-gothic);
            font-size: clamp(3rem, 12vw, 5rem); margin: 10px 0; text-align: center;
            text-shadow: 0 0 15px var(--primary-color), 3px 3px 8px rgba(0, 0, 0, 0.9);
            flex-shrink: 0; letter-spacing: 4px;
        }
        #status-bar { width: 100%; max-width: 600px; margin: 0 auto 10px auto; padding: 8px; background: var(--surface-color); border-radius: 8px; border: 1px solid #444; flex-shrink: 0; display: flex; justify-content: space-around; align-items: center; font-size: clamp(0.9rem, 3vw, 1.1rem); font-weight: bold; letter-spacing: 1px; }
        #status-bar span { color: var(--primary-color); } #status-bar #score-status span { color: #ffdc00; }
        #health-status { font-size: 1.5rem; color: #333; display: flex; gap: 4px; }
        .heart.pulsing { color: black; text-shadow: 0 0 5px var(--primary-color); animation: heart-pulse 2s infinite; }
        .heart.lost { color: var(--primary-color); animation: none; }
        @keyframes heart-pulse { 50% { color: var(--primary-color); text-shadow: 0 0 10px var(--primary-color); } }
        #game-container { flex-grow: 1; display: flex; flex-direction: column; gap: 0; padding: 10px; min-height: 0; }
        #game-area { flex-grow: 1; display: flex; align-items: center; justify-content: center; width: 100%; min-height: 0; }
        #canvas-wrapper { position: relative; background: black; border: 2px solid #555; box-shadow: 0 0 20px var(--primary-color); flex-shrink: 0; }
        canvas { display: block; width: 100%; height: 100%; }
        .overlay { position: absolute; inset: 0; background-color: rgba(0,0,0,0.85); backdrop-filter: blur(5px); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; padding: 15px; text-align: center; opacity: 0; visibility: hidden; transition: opacity 0.5s ease, visibility 0.5s ease; overflow-y: auto; }
        .overlay.visible { opacity: 1; visibility: visible; }
        .overlay.intro-specific { background-color: #000; backdrop-filter: none; }
        .overlay h2 { font-size: clamp(3rem, 15vw, 5rem); margin-bottom: 20px; font-family: var(--font-gothic); letter-spacing: 2px; }
        .overlay h3 { font-size: 1.8rem; letter-spacing: 1px; text-align: center; }
        .overlay p { font-size: clamp(1.2rem, 5vw, 1.5rem); letter-spacing: 1px; margin-top: 0; text-align: left; max-width: 500px; width: 90%; }
        .overlay ul { list-style: none; padding: 0; text-align: left; max-width: 500px; width: 100%;}
        #start-screen h2, #intro-screen h2 { color: var(--primary-color); text-shadow: 0 0 4px #000, 0 0 10px var(--primary-color), 0 0 25px #ff4136; }
        #intro-screen h2 { animation: real-heartbeat 2s ease-in-out infinite; }
        .overlay button { font-family: var(--font-gothic); padding: 15px 30px; font-size: clamp(1.2rem, 5vw, 1.8rem); cursor: pointer; border: none; border-radius: 8px; margin-top: 30px; color: #fff; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); transition: transform 0.1s ease, background-color 0.2s; }
        .overlay button:disabled { background-color: #555 !important; cursor: not-allowed; box-shadow: none !important; animation: none !important; }
        .overlay button:active:not(:disabled) { transform: scale(0.95); }
        #game-over h2, #win-screen h2, #new-highscore-screen h2 { color: var(--primary-color); } #level-complete h2 { color: var(--secondary-color); }
        .btn-blood { background: linear-gradient(to top, var(--primary-dark-color) 0%, var(--primary-color) 5%, var(--primary-dark-color) 10%); background-size: 100% 1000%; background-position: 50% 100%; box-shadow: 0 5px var(--primary-dark-color); animation: blood-drip 5s linear infinite; }
        .btn-go { background: linear-gradient(to bottom, #777, #444); box-shadow: inset 0 0 8px rgba(0,0,0,0.7); border: 1px solid #aaa; }
        .btn-go:active:not(:disabled) { background: linear-gradient(to bottom, #444, #777); box-shadow: inset 0 0 12px rgba(0,0,0,0.9); transform: scale(0.95); }
        @keyframes blood-drip { from { background-position: 50% 100%; } to { background-position: 50% 0%; } }
        @keyframes real-heartbeat { 0% { transform: scale(1); text-shadow: 0 0 10px var(--primary-color); } 10% { transform: scale(1.1); text-shadow: 0 0 30px var(--primary-color); } 20% { transform: scale(1); text-shadow: 0 0 10px var(--primary-color); } 30% { transform: scale(1.15); text-shadow: 0 0 40px #ff4136; } 45% { transform: scale(1); text-shadow: 0 0 10px var(--primary-color); } 100% { transform: scale(1); text-shadow: 0 0 10px var(--primary-color); } }
        #controls-dashboard { display: none; flex-shrink: 0; align-items: center; justify-content: space-between; width: 100%; padding: 20px 20px 20px 20px; }
        body.touch-enabled #controls-dashboard { display: flex; }
        .dpad { display: grid; grid-template-areas: ". up ." "left . right" ". down ."; width: 150px; height: 150px; }
        .dpad-btn { background: #444; color: white; border: 2px solid #888; border-radius: 30px; font-size: 26px; display:flex; justify-content: center; align-items: center; }
        .dpad-btn:active, .action-btn:active { background-color: #666; transform: scale(0.95); }
        #btn-up { grid-area: up; } #btn-left { grid-area: left; } #btn-right { grid-area: right; } #btn-down { grid-area: down; }
        .action-btn { width: 120px; height: 120px; background: var(--primary-dark-color); color: white; border: 2px solid var(--primary-color); border-radius: 50%; font-size: 24px; font-weight: bold; }
    </style>
</head>
<body>
    <div id="app-wrapper">
        <h1>Redmark</h1>
        <div id="status-bar" style="visibility: hidden;">
            <div id="health-status"></div>
            <div id="score-status">Score: <span>0</span></div>
            <div id="highscore-status">High: <span>0</span></div>
            <div id="level-status">Level: <span>1</span></div>
        </div>
        <div id="game-container">
            <div id="game-area">
                <div id="canvas-wrapper">
                    <canvas id="gameCanvas"></canvas>
                    <div id="intro-screen" class="overlay visible intro-specific"><h2>Redmark</h2></div>
                    <div id="how-to-play-screen" class="overlay">
                        <h2>How to Play</h2>
                        <p>Survive the hunt. Use the controls to move and shoot. Clear all vampires to advance.</p>
                        <h3>Enemies:</h3>
                        <ul>
                            <li style="display: flex; align-items: center; margin-bottom: 15px;">
                                <img src="https://cmstewardjr.github.io/Redmark/Vampire_1_Run_Front.png" alt="Red Vampire" style="width: 50px; height: auto; margin-right: 15px; background: #333; border-radius: 5px; border: 1px solid var(--primary-color);">
                                <div><span style="color:var(--primary-color)">Vampire:</span> 2 Shots to kill. (50 pts)</div>
                            </li>
                            <li style="display: flex; align-items: center; margin-bottom: 15px;">
                                <img src="https://cmstewardjr.github.io/Redmark/Vampire_2_Run_Front.png" alt="Purple Vampire" style="width: 50px; height: auto; margin-right: 15px; background: #333; border-radius: 5px; border: 1px solid var(--vampire-purple);">
                                <div><span style="color:var(--vampire-purple)">Vampire:</span> 3 Shots to kill. (100 pts)</div>
                            </li>
                            <li style="display: flex; align-items: center; margin-bottom: 15px;">
                                <img src="https://cmstewardjr.github.io/Redmark/Vampire_3_Run_Front.png" alt="Orange Vampire" style="width: 50px; height: auto; margin-right: 15px; background: #333; border-radius: 5px; border: 1px solid var(--vampire-orange);">
                                <div><span style="color:var(--vampire-orange)">Vampire:</span> 4 Shots to kill. (150 pts)</div>
                            </li>
                        </ul>
                        <button id="how-to-play-continue" class="btn-go">Continue</button>
                    </div>
                    <div id="new-enemy-screen" class="overlay">
                        <h2 id="new-enemy-title">New Threat!</h2>
                        <p id="new-enemy-desc">A new vampire has entered the hunt.</p>
                        <button id="new-enemy-continue" class="btn-go">Continue</button>
                    </div>
                    <div id="start-screen" class="overlay"><h2>Redmark</h2><p>The arena is marked. Survive the hunt.</p><button id="start-game-button" class="btn-blood">Start Game</button></div>
                    <div id="game-over" class="overlay"><h2>RIP ☠️</h2><p id="final-score-text">Score: 0</p><button id="continue-button" class="btn-blood">Continue</button><button id="quit-button" class="btn-go">Quit</button></div>
                    <div id="quit-confirm-screen" class="overlay"><h2>Are you sure?</h2><button id="quit-yes-button" class="btn-blood">Yes</button><button id="quit-no-button" class="btn-go">No</button></div>
                    <div id="new-highscore-screen" class="overlay"><h2>New High Score!</h2><p id="new-highscore-text">0</p><button id="play-again-hs-button" class="btn-blood">Play Again</button></div>
                    <div id="level-complete" class="overlay"><h2>Level Complete!</h2><button id="next-level-button" class="btn-go">Next Level</button></div>
                    <div id="win-screen" class="overlay"><h2>YOU WIN!</h2><p>You survived the hunt.</p><button id="play-again-win-button" class="btn-blood">Play Again</button></div>
                </div>
            </div>
            <div id="controls-dashboard">
                <div class="dpad"><button id="btn-up" class="dpad-btn">▲</button><button id="btn-left" class="dpad-btn">◀</button><button id="btn-right" class="dpad-btn">▶</button><button id="btn-down" class="dpad-btn">▼</button></div>
                <div class="actions"><button id="btn-shoot" class="action-btn">SHOOT</button></div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
            const overlays = { intro: document.getElementById('intro-screen'), howToPlay: document.getElementById('how-to-play-screen'), newEnemy: document.getElementById('new-enemy-screen'), start: document.getElementById('start-screen'), gameOver: document.getElementById('game-over'), levelComplete: document.getElementById('level-complete'), win: document.getElementById('win-screen'), newHighScore: document.getElementById('new-highscore-screen'), quitConfirm: document.getElementById('quit-confirm-screen') };
            const status = { level: document.querySelector('#level-status span'), score: document.querySelector('#score-status span'), highScore: document.querySelector('#highscore-status span'), health: document.getElementById('health-status') };
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0); if (isTouchDevice) document.body.classList.add('touch-enabled');
            
            const TILE_SIZE = 55;
            const COLS = 15;
            const ROWS = 13;
            const TOTAL_LEVELS = 6;
            canvas.width = COLS * TILE_SIZE; 
            canvas.height = ROWS * TILE_SIZE;

            const SPRITE_BASE_URL = 'https://cmstewardjr.github.io/Redmark/';
            const imageAssets = {
                player: {
                    front1: 'RedMark_Front1.png', front2: 'RedMark_Front2.png',
                    left: 'RedMark_Left.png', right: 'RedMark_Right.png',
                    behind1: 'RedMark_Behind1.png', behind2: 'RedMark_Behind2.png',
                },
                vampire1: {
                    run: { front: 'Vampire_1_Run_Front.png', left: 'Vampire_1_Run_Left.png', right: 'Vampire_1_Run_Right.png', behind: 'Vampire_1_Run_Behind.png' },
                    hurt: { front: 'Vampire_1_Front_Hurt.png', left: 'Vampire_1_Left_Hurt.png', right: 'Vampire_1_Right_Hurt.png', behind: 'Vampire_1_Behind_Hurt.png' }
                },
                vampire2: {
                    run: { front: 'Vampire_2_Run_Front.png', left: 'Vampire_2_Run_Left.png', right: 'Vampire_2_Run_Right.png', behind: 'Vampire_2_Run_Behind.png' },
                    hurt: { front: 'Vampire_2_Front_Hurt.png', left: 'Vampire_2_Left_Hurt.png', right: 'Vampire_2_Right_Hurt.png', behind: 'Vampire_2_Behind_Hurt.png' }
                },
                vampire3: {
                    run: { front: 'Vampire_3_Run_Front.png', left: 'Vampire_3_Run_Left.png', right: 'Vampire_3_Run_Left.png', behind: 'Vampire_3_Run_Behind.png' },
                    hurt: { front: 'Vampire_3_Front_Hurt.png', left: 'Vampire_3_Left_Hurt.png', right: 'Vampire_3_Right_Hurt.png', behind: 'Vampire_3_Behind_Hurt.png' }
                },
                environment: {
                    wall: 'Collision.png', hazard2: 'Collision2.png',
                    hazard3: 'Collision3.png', hazard4: 'Collision4.png'
                }
            };

            const loadedImages = {};
            function loadImage(path) {
                return new Promise((resolve) => {
                    if (!path) { console.error("loadImage missing path."); resolve(createDummyImage()); return; }
                    const img = new Image();
                    img.src = SPRITE_BASE_URL + path;
                    img.onload = () => resolve(img);
                    img.onerror = () => { console.error(`Failed to load: ${path}`); resolve(createDummyImage()); };
                });
            }
            function createDummyImage() {
                const dc = document.createElement('canvas'); dc.width = TILE_SIZE; dc.height = TILE_SIZE;
                const dctx = dc.getContext('2d'); dctx.fillStyle = 'magenta'; dctx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
                return dc;
            }
            async function preloadAllImages() {
                const p = [];
                for (const cat in imageAssets) { for (const key in imageAssets[cat]) {
                    if(typeof imageAssets[cat][key] === 'object') {
                        for(const subKey in imageAssets[cat][key]) {
                            const path = imageAssets[cat][key][subKey];
                            p.push(loadImage(path).then(img => loadedImages[`${cat}_${key}_${subKey}`] = img));
                        }
                    } else {
                        const path = imageAssets[cat][key];
                        p.push(loadImage(path).then(img => loadedImages[`${cat}_${key}`] = img));
                    }
                }}
                p.push(loadImage('Collision.png').then(img => loadedImages.wall = img));
                p.push(loadImage('Collision2.png').then(img => loadedImages.hazard2 = img));
                p.push(loadImage('Collision3.png').then(img => loadedImages.hazard3 = img));
                p.push(loadImage('Collision4.png').then(img => loadedImages.hazard4 = img));
                return Promise.all(p);
            }
            
            let player, vampires, bullets, arrows, currentLevel, maze, gameState = 'intro';
            let score = 0, highScore = 0;
            let countdown = 3, countdownTimer = 1;
            let seenEnemies = new Set();
            let newEnemyToShow = null;
            
            const keys={ArrowUp:false,ArrowLeft:false,ArrowDown:false,ArrowRight:false,' ':false};
            let lastTime=0;

            const PLAYER_SPRITE_SIZE = TILE_SIZE * 1.5; 
            const VAMPIRE_SPRITE_SIZE = TILE_SIZE * 1.2;

            const createVampire=(x,y,type)=>{ 
                let h,c,spd, spriteKey; 
                switch(type){
                    case 'purple': h=3; c=getComputedStyle(document.documentElement).getPropertyValue('--vampire-purple'); spd=55+Math.random()*15; spriteKey='vampire2'; break;
                    case 'orange': h=4; c=getComputedStyle(document.documentElement).getPropertyValue('--vampire-orange'); spd=70+Math.random()*20; spriteKey='vampire3'; break;
                    default: h=2; c=getComputedStyle(document.documentElement).getPropertyValue('--primary-color'); spd=40+Math.random()*10; spriteKey='vampire1'; break;
                } 
                return{
                    x, y, type, radius:TILE_SIZE/3, speed:spd, health:h, maxHealth:h, color:c, path:[], repathTimer: 1, direction: 'front', hurtTimer: 0, spriteKey: spriteKey,
                    currentImage: loadedImages[`${spriteKey}_run_front`], aiState: 'wandering', wanderTarget: null, detectionRadius: TILE_SIZE * 5, shootCooldown: 2 + Math.random() * 2,
                };
            };
            const createPlayer=()=>({
                x:1.5*TILE_SIZE, y:1.5*TILE_SIZE, radius:TILE_SIZE/3, speed:150, direction:'right', shootCooldown:0, health:3, maxHealth:3, invincibilityTimer:0,
                currentImage: loadedImages.player_right, animationTimer: 0, animationFrame: 1
            });
            const createBullet=(x,y,dir)=>({x,y,radius:10,angle:Math.atan2(dir.y,dir.x),velX:dir.x*600,velY:dir.y*600});
            const createArrow=(x,y,dir)=>({x,y,radius:8,angle:Math.atan2(dir.y,dir.x),velX:dir.x*450,velY:dir.y*450});
            
            const isObstacle=(tx,ty)=>!maze||tx<0||tx>=COLS||ty<0||ty>=ROWS||maze[ty][tx] >= 1;
            const getEmptyTile=(forSpawning = false)=>{
                let x,y, tile;
                do{
                    x=Math.floor(Math.random()*COLS);
                    y=Math.floor(Math.random()*ROWS);
                    tile = maze[y][x];
                } while( (forSpawning && tile !== 0) || (!forSpawning && isObstacle(x,y)) );
                return{x:x*TILE_SIZE+TILE_SIZE/2,y:y*TILE_SIZE+TILE_SIZE/2};
            };

            function teleportPlayerToSafeLocation() { const { x, y } = getEmptyTile(true); player.x = x; player.y = y; }

            function moveEntity(entity, dx, dy, dt) {
                const r = entity.radius; const attemptedX = entity.x + dx * dt; const attemptedY = entity.y + dy * dt;
                const checkCollisionTiles = (checkX, checkY, radius) => {
                    const minGridX = Math.floor((checkX - radius) / TILE_SIZE), maxGridX = Math.floor((checkX + radius) / TILE_SIZE);
                    const minGridY = Math.floor((checkY - radius) / TILE_SIZE), maxGridY = Math.floor((checkY + radius) / TILE_SIZE);
                    for (let ty = Math.max(0,minGridY); ty <= Math.min(ROWS - 1, maxGridY); ty++) {
                        for (let tx = Math.max(0,minGridX); tx <= Math.min(COLS - 1, maxGridX); tx++) {
                            if (isObstacle(tx, ty)) {
                                const wallLeft = tx * TILE_SIZE, wallTop = ty * TILE_SIZE;
                                let testX = Math.max(wallLeft, Math.min(checkX, wallLeft + TILE_SIZE));
                                let testY = Math.max(wallTop, Math.min(checkY, wallTop + TILE_SIZE));
                                if ((checkX - testX)**2 + (checkY - testY)**2 < radius**2) return true;
                            }
                        }
                    }
                    return false;
                };
                if (!checkCollisionTiles(attemptedX, entity.y, r)) entity.x = attemptedX;
                if (!checkCollisionTiles(entity.x, attemptedY, r)) entity.y = attemptedY;
            }

            function update(dt) { if (gameState === 'playing') updateGame(dt); else if (gameState === 'countdown') updateCountdown(dt); }
            function updateCountdown(dt) {
                countdownTimer -= dt;
                if (countdownTimer <= 0) {
                    countdown--; countdownTimer = 1;
                    if (countdown <= 0) {
                        if (newEnemyToShow) {
                            const ed = { purple: { title: "New Threat: Purple", desc: "Faster and tougher. Takes 3 shots." }, orange: { title: "New Menace: Orange", desc: "The fastest and strongest. Takes 4 shots." }};
                            document.getElementById('new-enemy-title').textContent = ed[newEnemyToShow].title;
                            document.getElementById('new-enemy-desc').textContent = ed[newEnemyToShow].desc;
                            overlays.newEnemy.classList.add('visible'); gameState = 'newEnemyIntro';
                        } else { gameState = 'playing'; }
                    }
                }
            }
            
            function updateGame(dt) {
                if (!player || !vampires) return;
                player.shootCooldown -= dt; player.invincibilityTimer -= dt;

                let mX=0,mY=0; if(keys.ArrowLeft)mX=-1; if(keys.ArrowRight)mX=1; if(keys.ArrowUp)mY=-1; if(keys.ArrowDown)mY=1;
                const mag = Math.sqrt(mX*mX+mY*mY);
                if (mag > 0) { 
                    if (Math.abs(mX) > Math.abs(mY)) player.direction = mX < 0 ? 'left' : 'right';
                    else player.direction = mY < 0 ? 'behind' : 'front';
                    moveEntity(player, (mX/mag)*player.speed, (mY/mag)*player.speed, dt); 
                    player.animationTimer += dt;
                    if (player.animationTimer > 0.15) { player.animationFrame = player.animationFrame === 1 ? 2 : 1; player.animationTimer = 0; }
                }
                if (player.direction === 'front' || player.direction === 'behind') { player.currentImage = loadedImages[`player_${player.direction}${player.animationFrame}`]; } 
                else { player.currentImage = loadedImages[`player_${player.direction}`]; }
                if (keys[' '] && player.shootCooldown <= 0) { shoot(); player.shootCooldown = 0.3; }

                if (player.invincibilityTimer <= 0) {
                    const pTX = Math.floor(player.x/TILE_SIZE), pTY = Math.floor(player.y/TILE_SIZE);
                    if (maze[pTY][pTX] > 1) handlePlayerDamage();
                }
                
                vampires.forEach((v, i) => {
                    v.hurtTimer = Math.max(0, v.hurtTimer - dt);
                    const distToPlayer=Math.sqrt((player.x-v.x)**2+(player.y-v.y)**2);

                    if (distToPlayer < v.detectionRadius) {
                        v.aiState = 'attacking';
                        v.shootCooldown -= dt;
                        if (v.shootCooldown <= 0) { vampireShoot(v); v.shootCooldown = 2 + Math.random() * 2; }
                    } else { v.aiState = 'wandering'; }

                    if(player.invincibilityTimer <= 0 && distToPlayer < player.radius+v.radius) { 
                        handlePlayerDamage();
                        if (player.health <= 0) { endGame(); return; }
                    }
                    
                    v.repathTimer -= dt;
                    if (v.repathTimer <= 0 || !v.path || v.path.length === 0) {
                        v.repathTimer = 1.5 + Math.random();
                        const start = {x:Math.floor(v.x/TILE_SIZE),y:Math.floor(v.y/TILE_SIZE)};
                        let end;
                        if (v.aiState === 'attacking') { end = {x:Math.floor(player.x/TILE_SIZE),y:Math.floor(player.y/TILE_SIZE)}; } 
                        else {
                            if (!v.wanderTarget || (Math.floor(v.x/TILE_SIZE) === v.wanderTarget.x && Math.floor(v.y/TILE_SIZE) === v.wanderTarget.y)) {
                                const randomTile = getEmptyTile();
                                v.wanderTarget = { x: Math.floor(randomTile.x/TILE_SIZE), y: Math.floor(randomTile.y/TILE_SIZE) };
                            }
                            end = v.wanderTarget;
                        }
                        v.path = findPath(start, end);
                    }
                    
                    if(v.path && v.path.length > 0){
                        const nextStep = v.path[0]; const tX = nextStep.x*TILE_SIZE+TILE_SIZE/2, tY = nextStep.y*TILE_SIZE+TILE_SIZE/2;
                        const dx = tX - v.x, dy = tY - v.y, dist = Math.sqrt(dx*dx+dy*dy);
                        if (dist > 0.1) {
                            if (Math.abs(dx) > Math.abs(dy)) v.direction = dx < 0 ? 'left' : 'right'; else v.direction = dy < 0 ? 'behind' : 'front';
                            moveEntity(v, (dx/dist)*v.speed, (dy/dist)*v.speed, dt);
                        }
                        if (Math.floor(v.x/TILE_SIZE)===nextStep.x && Math.floor(v.y/TILE_SIZE)===nextStep.y) v.path.shift();
                    }
                    
                    const state = v.hurtTimer > 0 ? 'hurt' : 'run'; v.currentImage = loadedImages[`${v.spriteKey}_${state}_${v.direction}`];
                    for(let j=i+1;j<vampires.length;j++){
                        const o=vampires[j], vdx=o.x-v.x, vdy=o.y-v.y, vDist=Math.sqrt(vdx*vdx+vdy*vdy), min_dist=v.radius+o.radius;
                        if(vDist<min_dist){
                            const overlap=(min_dist-vDist), pX=(vdx/vDist)*(overlap/2), pY=(vdy/vDist)*(overlap/2);
                            v.x-=pX; v.y-=pY; o.x+=pX; o.y+=pY;
                        }
                    }
                });

                // Update Arrows
                for (let i = arrows.length-1; i >= 0; i--) {
                    const a = arrows[i]; a.x += a.velX * dt; a.y += a.velY * dt;
                    if(isObstacle(Math.floor(a.x/TILE_SIZE),Math.floor(a.y/TILE_SIZE))){arrows.splice(i, 1); continue;}
                    if(player.invincibilityTimer <= 0 && Math.sqrt((a.x-player.x)**2+(a.y-player.y)**2)<a.radius+player.radius){
                        handlePlayerDamage();
                        arrows.splice(i,1);
                        if(player.health <= 0) { endGame(); return; }
                        break;
                    }
                }
                
                for (let i = bullets.length-1; i >= 0; i--) {
                    const b = bullets[i]; b.x += b.velX * dt; b.y += b.velY * dt;
                    if(isObstacle(Math.floor(b.x/TILE_SIZE),Math.floor(b.y/TILE_SIZE))){bullets.splice(i, 1); continue;}
                    for(let j=vampires.length-1;j>=0;j--){
                        const v=vampires[j];
                        if(Math.sqrt((b.x-v.x)**2+(b.y-v.y)**2)<b.radius+v.radius){
                            v.health--; v.hurtTimer = 0.2; bullets.splice(i,1);
                            if(v.health<=0){
                                switch(v.type){ case'purple':score+=100;break; case'orange':score+=150;break; default:score+=50; } 
                                updateUI(); vampires.splice(j,1);
                            }
                            break;
                        }
                    }
                }
                if (vampires.length === 0 && gameState === 'playing') {
                    if (currentLevel < TOTAL_LEVELS) { overlays.levelComplete.classList.add('visible'); gameState = 'levelComplete'; } 
                    else { overlays.win.classList.add('visible'); gameState = 'win'; }
                }
            }
            function vampireShoot(v) {
                const dir = { x: player.x - v.x, y: player.y - v.y };
                const mag = Math.sqrt(dir.x**2 + dir.y**2);
                if (mag > 0) { dir.x /= mag; dir.y /= mag; }
                arrows.push(createArrow(v.x, v.y, dir));
            }
            function handlePlayerDamage() {
                player.health--; player.invincibilityTimer = 1.5; updateUI(true); teleportPlayerToSafeLocation();
            }
            function findPath(start, end) {
                const openSet = [], closedSet = new Set();
                const heuristic = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
                const startNode = { x: start.x, y: start.y, g: 0, h: heuristic(start, end), f: 0, parent: null };
                startNode.f = startNode.h; openSet.push(startNode);
                while (openSet.length > 0) {
                    let current = openSet.reduce((a, b) => a.f < b.f ? a : b);
                    if (current.x === end.x && current.y === end.y) {
                        const path = []; let temp = current;
                        while (temp && temp.parent) { path.unshift({ x: temp.x, y: temp.y }); temp = temp.parent; }
                        return path;
                    }
                    openSet.splice(openSet.indexOf(current), 1); closedSet.add(`${current.x},${current.y}`);
                    const neighbors = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
                    for (const { dx, dy } of neighbors) {
                        const nX = current.x + dx, nY = current.y + dy;
                        if (isObstacle(nX, nY) || closedSet.has(`${nX},${nY}`)) continue;
                        const gScore = current.g + 1;
                        let neighborNode = openSet.find(node => node.x === nX && node.y === nY);
                        if (!neighborNode) {
                            neighborNode = { x: nX, y: nY, g: gScore, h: heuristic({ x: nX, y: nY }, end), parent: current };
                            neighborNode.f = neighborNode.g + neighborNode.h; openSet.push(neighborNode);
                        } else if (gScore < neighborNode.g) { neighborNode.g = gScore; neighborNode.f = gScore + neighborNode.h; neighborNode.parent = current; }
                    }
                }
                return [];
            }
            function draw() {
                ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#4a2a2a'; ctx.fillRect(0,0,canvas.width,canvas.height);
                if (maze) {
                    for(let y=0;y<ROWS;y++){ for(let x=0;x<COLS;x++){
                        let img=null;
                        switch(maze[y][x]){case 1:img=loadedImages.wall;break;case 2:img=loadedImages.hazard2;break;case 3:img=loadedImages.hazard3;break;case 4:img=loadedImages.hazard4;break;}
                        if (img) ctx.drawImage(img,x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
                    }}
                }
                // Draw Arrows
                if(arrows){ctx.fillStyle='red';ctx.strokeStyle='#8B0000';ctx.lineWidth=2;arrows.forEach(a=>{ctx.save();ctx.translate(a.x,a.y);ctx.rotate(a.angle);ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(-a.radius, -a.radius/2);ctx.lineTo(-a.radius, a.radius/2);ctx.closePath();ctx.fill();ctx.stroke();ctx.restore();});}
                if(bullets){ctx.fillStyle='#2A52BE';ctx.strokeStyle='#ADD8E6';ctx.lineWidth=2;bullets.forEach(b=>{ctx.save();ctx.translate(b.x,b.y);ctx.rotate(b.angle);ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(-b.radius, -b.radius/2);ctx.lineTo(-b.radius, b.radius/2);ctx.closePath();ctx.fill();ctx.stroke();ctx.restore();});}
                if(vampires){vampires.forEach(v=>{if(v.currentImage){ctx.save();ctx.translate(v.x,v.y);if(v.spriteKey==='vampire3'&&v.direction==='right')ctx.scale(-1,1);ctx.drawImage(v.currentImage,-VAMPIRE_SPRITE_SIZE/2,-VAMPIRE_SPRITE_SIZE/2,VAMPIRE_SPRITE_SIZE,VAMPIRE_SPRITE_SIZE);ctx.restore();}});}
                if(player){
                    if(player.currentImage){ctx.save();ctx.translate(player.x,player.y);ctx.drawImage(player.currentImage,-PLAYER_SPRITE_SIZE/2,-PLAYER_SPRITE_SIZE/2,PLAYER_SPRITE_SIZE,PLAYER_SPRITE_SIZE);ctx.restore();}
                    if(player.invincibilityTimer>0){const pF=Math.abs(Math.sin(Date.now()*0.005));ctx.strokeStyle=`rgba(0,123,167,${0.5+pF*0.5})`;ctx.lineWidth=4;ctx.beginPath();ctx.arc(player.x,player.y,player.radius+3,0,Math.PI*2);ctx.stroke();}
                }
                if(gameState==='countdown'&&countdown>0){ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--primary-color');ctx.font=`bold 150px ${getComputedStyle(document.documentElement).getPropertyValue('--font-gothic')}`;ctx.textAlign="center";ctx.textBaseline="middle";ctx.strokeStyle="black";ctx.lineWidth=6;ctx.strokeText(countdown,canvas.width/2,canvas.height/2);ctx.fillText(countdown,canvas.width/2,canvas.height/2);}
            }
            function gameLoop(t){ const dt=(t-lastTime)/1000; lastTime=t; if(dt>0&&dt<1)update(dt); draw(); requestAnimationFrame(gameLoop); }
            function resizeGame() { const gA=document.getElementById('game-area'),cW=document.getElementById('canvas-wrapper'),aW=gA.clientWidth,aH=gA.clientHeight,cAR=canvas.width/canvas.height;let nW=aW,nH=nW/cAR;if(nH>aH){nH=aH;nW=nH*cAR;}cW.style.width=`${nW}px`;cW.style.height=`${nH}px`;}
            
            function generateLevelLayout() {
                let nM=Array.from({length:ROWS},()=>Array(COLS).fill(0));
                for (let y=0;y<ROWS;y++) { for (let x=0;x<COLS;x++) { if (y===0||y===ROWS-1||x===0||x===COLS-1) nM[y][x]=1;}}
                const numHazards=Math.floor(COLS*ROWS*0.1);
                for(let i=0;i<numHazards;i++){
                    const hx=Math.floor(Math.random()*(COLS-2))+1,hy=Math.floor(Math.random()*(ROWS-2))+1;
                    if(nM[hy][hx]===0 && Math.sqrt((hx-1.5)**2+(hy-1.5)**2)>3)nM[hy][hx]=Math.floor(Math.random()*3)+2;
                }
                return nM;
            }

            function setupLevel(level){
                currentLevel=level; maze=generateLevelLayout(); player=createPlayer(); vampires=[]; bullets=[]; arrows=[]; newEnemyToShow = null;
                if(level===1){score=0; seenEnemies = new Set(['red']);} countdown=3; countdownTimer=1; gameState='countdown';
                let enemyTypesToSpawn=[],redCount=4+(level-1),purpleCount=0,orangeCount=0; 
                if (level >= 2) purpleCount = Math.floor(level / 2); if (level >= 4) orangeCount = Math.floor((level - 2) / 2);
                for(let i=0;i<redCount;i++)enemyTypesToSpawn.push('red'); for(let i=0;i<purpleCount;i++)enemyTypesToSpawn.push('purple'); for(let i=0;i<orangeCount;i++)enemyTypesToSpawn.push('orange');
                enemyTypesToSpawn.forEach(type=>{const tile=getEmptyTile(true);vampires.push(createVampire(tile.x,tile.y,type));});
                enemyTypesToSpawn.forEach(type=>{if(!seenEnemies.has(type)){newEnemyToShow=type;seenEnemies.add(type);}});
                Object.values(overlays).forEach(o=>o.classList.remove('visible')); document.getElementById('status-bar').style.visibility='visible'; updateUI();
            }
            function init(){ 
                highScore=parseInt(localStorage.getItem('redmarkHighScore'))||0; 
                preloadAllImages().then(() => {
                    setTimeout(() => { overlays.intro.classList.remove('visible'); overlays.howToPlay.classList.add('visible'); }, 4000);
                    resizeGame(); initEventListeners(); requestAnimationFrame(gameLoop);
                }).catch(error => { console.error("Error preloading images:", error); alert("Failed to load game assets."); });
            }
            function initEventListeners() {
                window.addEventListener('resize',()=>resizeGame());
                document.getElementById('how-to-play-continue').addEventListener('click', () => { overlays.howToPlay.classList.remove('visible'); overlays.start.classList.add('visible'); gameState = 'startScreen'; });
                document.getElementById('new-enemy-continue').addEventListener('click', () => { overlays.newEnemy.classList.remove('visible'); gameState = 'playing'; });
                document.getElementById('start-game-button').addEventListener('click', ()=>setupLevel(1));
                document.getElementById('continue-button').addEventListener('click', ()=>setupLevel(1));
                document.getElementById('play-again-hs-button').addEventListener('click', ()=>setupLevel(1));
                document.getElementById('play-again-win-button').addEventListener('click', ()=>setupLevel(1));
                document.getElementById('next-level-button').addEventListener('click', ()=>{if(currentLevel<TOTAL_LEVELS)setupLevel(currentLevel+1);else{overlays.levelComplete.classList.remove('visible'); overlays.win.classList.add('visible'); gameState='win';}}); 
                document.getElementById('quit-button').addEventListener('click', ()=>{overlays.gameOver.classList.remove('visible');overlays.newHighScore.classList.remove('visible');overlays.quitConfirm.classList.add('visible');});
                document.getElementById('quit-no-button').addEventListener('click', ()=>{overlays.quitConfirm.classList.remove('visible');endGame(true);});
                document.getElementById('quit-yes-button').addEventListener('click', ()=>{overlays.quitConfirm.classList.remove('visible');overlays.start.classList.add('visible');gameState='startScreen';document.getElementById('status-bar').style.visibility='hidden';});
                window.addEventListener('keydown', (e)=>{if(e.key in keys){if(e.key===' '||e.key.startsWith('Arrow'))e.preventDefault();keys[e.key]=true;}});window.addEventListener('keyup',(e)=>{if(e.key in keys){keys[e.key]=false;}});
                const d=document.querySelector('.dpad'),sB=document.getElementById('btn-shoot');const rDK=()=>{keys.ArrowUp=false;keys.ArrowDown=false;keys.ArrowLeft=false;keys.ArrowRight=false;};const hDT=(e)=>{e.preventDefault();const t=e.touches[0];const eUT=document.elementFromPoint(t.clientX,t.clientY);rDK();if(eUT){switch(eUT.id){case'btn-up':keys.ArrowUp=true;break;case'btn-down':keys.ArrowDown=true;break;case'btn-left':keys.ArrowLeft=true;break;case'btn-right':keys.ArrowRight=true;break;}}};d.addEventListener('touchstart',hDT,{passive:false});d.addEventListener('touchmove',hDT,{passive:false});d.addEventListener('touchend',rDK,{passive:false});d.addEventListener('touchcancel',rDK,{passive:false});sB.addEventListener('touchstart',(e)=>{e.preventDefault();keys[' ']=true;},{passive:false});sB.addEventListener('touchend',(e)=>{e.preventDefault();keys[' ']=false;},{passive:false});
            }
            function endGame(recoveringFromQuit=false){
                if(!recoveringFromQuit) gameState='gameOver'; 
                if(score>highScore){highScore=score;localStorage.setItem('redmarkHighScore',highScore);document.getElementById('new-highscore-text').textContent=score;overlays.newHighScore.classList.add('visible');}
                else{document.getElementById('final-score-text').textContent=`Score: ${score}`;overlays.gameOver.classList.add('visible');}
            }
            function shoot(){
                let dir={x:0,y:0};
                if(player.direction==='behind')dir.y=-1;else if(player.direction==='front')dir.y=1;else if(player.direction==='left')dir.x=-1;else if(player.direction==='right')dir.x=1;
                if(dir.x===0&&dir.y===0)dir.x=1;
                const mag=Math.sqrt(dir.x**2+dir.y**2);if(mag>0){dir.x/=mag;dir.y/=mag;}
                bullets.push(createBullet(player.x,player.y,dir));
            }
            function updateUI(hit = false) {
                if(!player)return;status.level.textContent=currentLevel;status.score.textContent=score;status.highScore.textContent=highScore;status.health.innerHTML='';
                for(let i=0;i<player.maxHealth;i++){
                    const hS=document.createElement('span');
                    if(i<player.health){hS.textContent='🖤';hS.className='heart pulsing';}
                    else{if(hit&&i===player.health){hS.textContent='💀';setTimeout(()=>{hS.textContent='🖤';hS.className='heart lost';},1000);}else{hS.textContent='🖤';hS.className='heart lost';}}
                    status.health.appendChild(hS);
                }
            }
            init();
        });
    </script>
</body>
</html>
