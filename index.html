<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Redmark</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Metal+Mania&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #100000; --surface-color: #1e1e1e; --text-color: #f0f0f0;
            --primary-color: #a00000; --primary-dark-color: #6e0000; --secondary-color: #2ecc40;
            --secondary-dark-color: #27ae60; --font-gothic: 'Metal Mania', cursive;
            --vampire-purple: #8A2BE2; --vampire-orange: #FF8C00; --cerulean-blue: #007BA7;
        }
        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; width: 100%; margin: 0; padding: 0; overflow: hidden; background-color: var(--bg-color); }
        #app-wrapper {
            display: flex;
            flex-direction: column;
            height: 100dvh;
            width: 100%;
            color: var(--text-color);
            font-family: var(--font-gothic);
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: var(--primary-color); font-family: var(--font-gothic);
            font-size: clamp(2.5rem, 10vw, 4rem); margin: 5px 0; text-align: center;
            text-shadow: 0 0 15px var(--primary-color), 3px 3px 8px rgba(0, 0, 0, 0.9);
            flex-shrink: 0; letter-spacing: 4px;
        }
        #status-bar { width: 100%; max-width: 600px; margin: 0 auto 5px auto; padding: 6px; background: var(--surface-color); border-radius: 8px; border: 1px solid #444; flex-shrink: 0; display: flex; justify-content: space-around; align-items: center; font-size: clamp(0.8rem, 2.5vw, 1rem); font-weight: bold; letter-spacing: 1px; }
        #status-bar span { color: var(--primary-color); } #status-bar #score-status span { color: #ffdc00; }
        #health-status { font-size: 1.2rem; color: #333; display: flex; gap: 4px; }
        .heart.pulsing { color: black; text-shadow: 0 0 5px var(--primary-color); animation: heart-pulse 2s infinite; }
        .heart.lost { color: var(--primary-color); animation: none; }
        @keyframes heart-pulse { 50% { color: var(--primary-color); text-shadow: 0 0 10px var(--primary-color); } }
        
        #game-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 10px;
            min-height: 0;
        }
        #game-area {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 0;
        }
        #controls-dashboard {
            display: none;
            flex-shrink: 0;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: 10px 20px 20px 20px;
        }
        body.touch-enabled #controls-dashboard {
            display: flex;
            flex-direction: row;
        }

        #canvas-wrapper { position: relative; background: black; border: 2px solid #555; box-shadow: 0 0 20px var(--primary-color); flex-shrink: 0; }
        canvas { display: block; width: 100%; height: 100%; }
        .overlay { position: absolute; inset: 0; background-color: rgba(0,0,0,0.85); backdrop-filter: blur(5px); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; padding: 15px; text-align: center; opacity: 0; visibility: hidden; transition: opacity 0.5s ease, visibility 0.5s ease; overflow-y: auto; }
        .overlay.visible { opacity: 1; visibility: visible; }
        .overlay.intro-specific { background-color: #000; backdrop-filter: none; }
        .overlay h2 { font-size: clamp(3rem, 15vw, 5rem); margin-bottom: 20px; font-family: var(--font-gothic); letter-spacing: 2px; }
        .overlay p { font-size: clamp(1.2rem, 5vw, 1.5rem); letter-spacing: 1px; margin-top: 0; text-align: left; max-width: 500px; width: 90%; }
        .overlay ul { list-style: none; padding: 0; text-align: left; max-width: 500px; width: 100%;}
        #start-screen h2, #intro-screen h2 { color: var(--primary-color); text-shadow: 0 0 4px #000, 0 0 10px var(--primary-color), 0 0 25px #ff4136; }
        #intro-screen h2 { animation: real-heartbeat 2s ease-in-out infinite; }
        .overlay button { font-family: var(--font-gothic); padding: 15px 30px; font-size: clamp(1.2rem, 5vw, 1.8rem); cursor: pointer; border: none; border-radius: 8px; margin-top: 30px; color: #fff; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); transition: transform 0.1s ease, background-color 0.2s; }
        .btn-blood { background: linear-gradient(to top, var(--primary-dark-color) 0%, var(--primary-color) 5%, var(--primary-dark-color) 10%); background-size: 100% 1000%; background-position: 50% 100%; box-shadow: 0 5px var(--primary-dark-color); animation: blood-drip 5s linear infinite; }
        .btn-go { background: linear-gradient(to bottom, #777, #444); box-shadow: inset 0 0 8px rgba(0,0,0,0.7); border: 1px solid #aaa; }

        #joystick-container {
            width: 150px;
            height: 150px;
            position: relative;
        }
        #joystick-base {
            width: 100%;
            height: 100%;
            background: #333;
            border-radius: 50%;
            border: 2px solid #555;
            position: absolute;
        }
        #joystick-nub {
            width: 60px;
            height: 60px;
            background: #555;
            border-radius: 50%;
            position: absolute;
            top: 45px;
            left: 45px;
            cursor: grab;
            border: 2px solid #888;
        }
        .action-btn { width: 120px; height: 120px; background: var(--primary-dark-color); color: white; border: 2px solid var(--primary-color); border-radius: 50%; font-size: 24px; font-weight: bold; }
        @keyframes real-heartbeat { 0% { transform: scale(1); text-shadow: 0 0 10px var(--primary-color); } 10% { transform: scale(1.1); text-shadow: 0 0 30px var(--primary-color); } 20% { transform: scale(1); text-shadow: 0 0 10px var(--primary-color); } 30% { transform: scale(1.15); text-shadow: 0 0 40px #ff4136; } 45% { transform: scale(1); text-shadow: 0 0 10px var(--primary-color); } 100% { transform: scale(1); text-shadow: 0 0 10px var(--primary-color); } }
    </style>
</head>
<body>
    <div id="app-wrapper">
        <h1>Redmark</h1>
        <div id="status-bar" style="visibility: hidden;">
            <div id="health-status"></div>
            <div id="score-status">Score: <span>0</span></div>
            <div id="highscore-status">High: <span>0</span></div>
            <div id="level-status">Level: <span>1</span></div>
        </div>
        <div id="game-container">
            <div id="game-area">
                <div id="canvas-wrapper">
                    <canvas id="gameCanvas"></canvas>
                    <div id="intro-screen" class="overlay visible intro-specific"><h2>Redmark</h2></div>
                    <div id="how-to-play-screen" class="overlay">
                        <h2>How to Play</h2>
                        <p>Survive the hunt. Use the controls to move and shoot. Clear all vampires to advance.</p>
                        <h3>Enemies:</h3>
                        <ul>
                            <li style="display: flex; align-items: center; margin-bottom: 15px;">
                                <img src="https://cmstewardjr.github.io/Redmark/Vampire_1_Run_Front.png" alt="Red Vampire" style="width: 50px; height: auto; margin-right: 15px; background: #333; border-radius: 5px; border: 1px solid var(--primary-color);">
                                <div><span style="color:var(--primary-color)">Vampire:</span> 2 Shots to kill. (50 pts)</div>
                            </li>
                            <li style="display: flex; align-items: center; margin-bottom: 15px;">
                                <img src="https://cmstewardjr.github.io/Redmark/Vampire_2_Run_Front.png" alt="Purple Vampire" style="width: 50px; height: auto; margin-right: 15px; background: #333; border-radius: 5px; border: 1px solid var(--vampire-purple);">
                                <div><span style="color:var(--vampire-purple)">Vampire:</span> 3 Shots to kill. (100 pts)</div>
                            </li>
                            <li style="display: flex; align-items: center; margin-bottom: 15px;">
                                <img src="https://cmstewardjr.github.io/Redmark/Vampire_3_Run_Front.png" alt="Orange Vampire" style="width: 50px; height: auto; margin-right: 15px; background: #333; border-radius: 5px; border: 1px solid var(--vampire-orange);">
                                <div><span style="color:var(--vampire-orange)">Vampire:</span> 4 Shots to kill. (150 pts)</div>
                            </li>
                        </ul>
                        <button id="how-to-play-continue" class="btn-go">Continue</button>
                    </div>
                    <div id="new-enemy-screen" class="overlay"><h2>New Threat!</h2><p id="new-enemy-desc">A new vampire has entered the hunt.</p><button id="new-enemy-continue" class="btn-go">Continue</button></div>
                    <div id="start-screen" class="overlay"><h2>Redmark</h2><p>The arena is marked. Survive the hunt.</p><button id="start-game-button" class="btn-blood">Start Game</button></div>
                    <div id="game-over" class="overlay"><h2>RIP ☠️</h2><p id="final-score-text">Score: 0</p><button id="continue-button" class="btn-blood">Continue</button><button id="quit-button" class="btn-go">Quit</button></div>
                    <div id="quit-confirm-screen" class="overlay"><h2>Are you sure?</h2><button id="quit-yes-button" class="btn-blood">Yes</button><button id="quit-no-button" class="btn-go">No</button></div>
                    <div id="new-highscore-screen" class="overlay"><h2>New High Score!</h2><p id="new-highscore-text">0</p><button id="play-again-hs-button" class="btn-blood">Play Again</button></div>
                    <div id="level-complete" class="overlay"><h2>Level Complete!</h2><button id="next-level-button" class="btn-go">Next Level</button></div>
                    <div id="win-screen" class="overlay"><h2>YOU WIN!</h2><p>You survived the hunt.</p><button id="play-again-win-button" class="btn-blood">Play Again</button></div>
                </div>
            </div>
            <div id="controls-dashboard">
                <div id="joystick-container">
                    <div id="joystick-base"></div>
                    <div id="joystick-nub"></div>
                </div>
                <div class="actions"><button id="btn-shoot" class="action-btn">SHOOT</button></div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
            const overlays = { intro: document.getElementById('intro-screen'), howToPlay: document.getElementById('how-to-play-screen'), newEnemy: document.getElementById('new-enemy-screen'), start: document.getElementById('start-screen'), gameOver: document.getElementById('game-over'), levelComplete: document.getElementById('level-complete'), win: document.getElementById('win-screen'), newHighScore: document.getElementById('new-highscore-screen'), quitConfirm: document.getElementById('quit-confirm-screen') };
            const status = { level: document.querySelector('#level-status span'), score: document.querySelector('#score-status span'), highScore: document.querySelector('#highscore-status span'), health: document.getElementById('health-status') };
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0); if (isTouchDevice) document.body.classList.add('touch-enabled');
            
            const TILE_SIZE = 55;
            const COLS = 15;
            const ROWS = 17; // Expanded the play area vertically
            const TOTAL_LEVELS = 20; // Increased total levels to 20
            const MIN_PLAYER_SPAWN_DISTANCE = TILE_SIZE * 7; // Increased min distance for vampires to spawn from player
            canvas.width = COLS * TILE_SIZE; 
            canvas.height = ROWS * TILE_SIZE;

            const SPRITE_BASE_URL = 'https://cmstewardjr.github.io/Redmark/';
            const imageAssets = { player: { front1: 'RedMark_Front1.png', front2: 'RedMark_Front2.png', left: 'RedMark_Left.png', right: 'RedMark_Right.png', behind1: 'RedMark_Behind1.png', behind2: 'RedMark_Behind2.png', }, vampire1: { run: { front: 'Vampire_1_Run_Front.png', left: 'Vampire_1_Run_Left.png', right: 'Vampire_1_Run_Right.png', behind: 'Vampire_1_Run_Behind.png' }, hurt: { front: 'Vampire_1_Front_Hurt.png', left: 'Vampire_1_Left_Hurt.png', right: 'Vampire_1_Right_Hurt.png', behind: 'Vampire_1_Behind_Hurt.png' } }, vampire2: { run: { front: 'Vampire_2_Run_Front.png', left: 'Vampire_2_Run_Left.png', right: 'Vampire_2_Run_Right.png', behind: 'Vampire_2_Run_Behind.png' }, hurt: { front: 'Vampire_2_Front_Hurt.png', left: 'Vampire_2_Left_Hurt.png', right: 'Vampire_2_Right_Hurt.png', behind: 'Vampire_2_Behind_Hurt.png' } }, vampire3: { run: { front: 'Vampire_3_Run_Front.png', left: 'Vampire_3_Run_Left.png', right: 'Vampire_3_Run_Left.png', behind: 'Vampire_3_Run_Behind.png' }, hurt: { front: 'Vampire_3_Front_Hurt.png', left: 'Vampire_3_Left_Hurt.png', right: 'Vampire_3_Right_Hurt.png', behind: 'Vampire_3_Behind_Hurt.png' } }, environment: { wall: 'Collision.png', hazard2: 'Collision2.png', hazard3: 'Collision3.png', hazard4: 'Collision4.png' } };

            const loadedImages = {};
            function loadImage(path) { return new Promise((resolve) => { if (!path) { console.error("loadImage missing path."); resolve(createDummyImage()); return; } const img = new Image(); img.src = SPRITE_BASE_URL + path; img.onload = () => resolve(img); img.onerror = () => { console.error(`Failed to load: ${path}`); resolve(createDummyImage()); }; }); }
            function createDummyImage() { const dc = document.createElement('canvas'); dc.width = TILE_SIZE; dc.height = TILE_SIZE; const dctx = dc.getContext('2d'); dctx.fillStyle = 'magenta'; dctx.fillRect(0, 0, TILE_SIZE, TILE_SIZE); return dc; }
            async function preloadAllImages() {
                const p = [];
                for (const cat in imageAssets) { for (const key in imageAssets[cat]) { if(typeof imageAssets[cat][key] === 'object') { for(const subKey in imageAssets[cat][key]) { const path = imageAssets[cat][key][subKey]; p.push(loadImage(path).then(img => loadedImages[`${cat}_${key}_${subKey}`] = img)); } } else { const path = imageAssets[cat][key]; p.push(loadImage(path).then(img => loadedImages[`${cat}_${key}`] = img)); } } }
                p.push(loadImage('Collision.png').then(img => loadedImages.wall = img));
                p.push(loadImage('Collision2.png').then(img => loadedImages.hazard2 = img));
                p.push(loadImage('Collision3.png').then(img => loadedImages.hazard3 = img));
                p.push(loadImage('Collision4.png').then(img => loadedImages.hazard4 = img));
                return Promise.all(p);
            }
            
            const PLAYER_SPRITE_SIZE = TILE_SIZE * 2.0; 
            const VAMPIRE_SPRITE_SIZE = TILE_SIZE * 2.1;

            const HAZARD_CONFIG = {
                2: { type: 2, radius: TILE_SIZE * 0.55 },
                3: { type: 3, radius: TILE_SIZE * 0.55 },
                4: { type: 4, radius: TILE_SIZE * 0.55 }
            };
            
            let player, vampires, bullets, arrows, hazards, currentLevel, maze, gameState = 'intro';
            let score = 0, highScore = 0;
            let countdown = 3, countdownTimer = 1;
            let goDisplayDuration = 0.5; // Duration for "GO!" display
            let newEnemyToShow = null;
            let seenEnemies = new Set();
            // let currentHazardType = 0; // No longer needed as each hazard gets a random type

            const keys={ArrowUp:false,ArrowLeft:false,ArrowDown:false,ArrowRight:false,' ':false};
            let joystick = { active: false, x: 0, y: 0, startX: 0, startY: 0, vectorX: 0, vectorY: 0 };
            let lastTime=0;

            const createVampire=(x,y,type)=>{ let h,c,spd, spriteKey; switch(type){ case 'purple': h=3; c=getComputedStyle(document.documentElement).getPropertyValue('--vampire-purple'); spd=100+Math.random()*10; spriteKey='vampire2'; break; case 'orange': h=4; c=getComputedStyle(document.documentElement).getPropertyValue('--vampire-orange'); spd=125+Math.random()*10; spriteKey='vampire3'; break; default: h=2; c=getComputedStyle(document.documentElement).getPropertyValue('--primary-color'); spd=80+Math.random()*10; spriteKey='vampire1'; break; } return{ x, y, type, radius:TILE_SIZE/3, speed:spd, health:h, maxHealth:h, color:c, path:[], repathTimer: 1, direction: 'front', hurtTimer: 0, spriteKey: spriteKey, currentImage: loadedImages[`${spriteKey}_run_front`], aiState: 'wandering', wanderTarget: null, detectionRadius: TILE_SIZE * 5, shootCooldown: 0.8 + Math.random() * 0.7, bobTimer: Math.random() * Math.PI * 2, bobAmount: 4 + Math.random() * 4 }; };
            const createPlayer=()=>({ x:1.5*TILE_SIZE, y:1.5*TILE_SIZE, radius:TILE_SIZE/3, speed:150, direction:'right', shootCooldown:0, health:6, maxHealth:6, invincibilityTimer:0, currentImage: loadedImages.player_right, animationTimer: 0, animationFrame: 1 }); // Increased player health to 6
            const createBullet=(x,y,dir)=>({x,y,radius:10,angle:Math.atan2(dir.y,dir.x),velX:dir.x*600,velY:dir.y*600});
            const createArrow=(x,y,dir)=>({x,y,radius:8,angle:Math.atan2(dir.y,dir.x),velX:dir.x*450,velY:dir.y*450});
            
            const isWall=(tx,ty)=>!maze||tx<0||tx>=COLS||ty<0||ty>=ROWS||maze[ty][tx] === 1;
            // New function: checks if a tile is blocked for pathfinding (wall or hazard)
            const isTileBlockedForPathfinding=(tx,ty)=>!maze||tx<0||tx>=COLS||ty<0||ty>=ROWS||maze[ty][tx] === 1 || maze[ty][tx] > 1;

            const getEmptyTile=()=>{ let x,y; do{ x=Math.floor(Math.random()*COLS); y=Math.floor(Math.random()*ROWS); } while(isWall(x,y)); return{x:x*TILE_SIZE+TILE_SIZE/2,y:y*TILE_SIZE+TILE_SIZE/2}; };
            
            // isObstacle checks for physical collision with walls or hazards
            function isObstacle(x, y, radius) { 
                const tileX = Math.floor(x / TILE_SIZE); 
                const tileY = Math.floor(y / TILE_SIZE); 
                if (isWall(tileX, tileY)) return true; 
                if (hazards) { 
                    for (const hazard of hazards) { 
                        const dist = Math.sqrt((x - hazard.x)**2 + (y - hazard.y)**2); 
                        if (dist < radius + hazard.radius) return true; 
                    } 
                } 
                return false; 
            }

            function teleportPlayerToSafeLocation() { let safePos; do { safePos = getEmptyTile(); } while (isObstacle(safePos.x, safePos.y, player.radius)); player.x = safePos.x; player.y = safePos.y; }
            
            // moveEntity now uses isObstacle for both players and vampires to prevent moving through hazards
            function moveEntity(entity, dx, dy, dt) { 
                const r = entity.radius; 
                const attemptedX = entity.x + dx * dt; 
                const attemptedY = entity.y + dy * dt; 

                // Check collision for X-axis movement
                if (!isObstacle(attemptedX, entity.y, r)) entity.x = attemptedX; 
                // Check collision for Y-axis movement
                if (!isObstacle(entity.x, attemptedY, r)) entity.y = attemptedY; 
            }

            function update(dt) { 
                if (gameState === 'playing') updateGame(dt); 
                else if (gameState === 'countdown') updateCountdown(dt); 
            }

            function updateCountdown(dt) { 
                countdownTimer -= dt; 
                if (countdownTimer <= 0) { 
                    countdown--; 
                    countdownTimer = 1; 
                    if (countdown < 0) { // Countdown finished
                        gameState = 'goDisplay';
                        // Schedule the transition to actual gameplay
                        setTimeout(() => {
                            gameState = 'playing'; 
                        }, goDisplayDuration * 1000); // Wait for goDisplayDuration
                        return; // Exit to avoid further countdown updates in this frame
                    } 
                } 
            }
            
            function updateGame(dt) {
                if (!player || !vampires) return;
                player.shootCooldown -= dt; player.invincibilityTimer -= dt;

                let mX=0,mY=0; 
                if (joystick.active) { 
                    // Cardinal movement for joystick
                    if (Math.abs(joystick.vectorX) > Math.abs(joystick.vectorY)) {
                        mX = Math.sign(joystick.vectorX);
                        mY = 0; // Lock to horizontal
                    } else {
                        mX = 0; // Lock to vertical
                        mY = Math.sign(joystick.vectorY);
                    }
                }
                else { 
                    if(keys.ArrowLeft)mX=-1; 
                    if(keys.ArrowRight)mX=1; 
                    if(keys.ArrowUp)mY=-1; 
                    if(keys.ArrowDown)mY=1; 
                    // Ensure only one direction is active for keyboard too
                    if (mX !== 0 && mY !== 0) {
                        if (Math.abs(mX) > Math.abs(mY)) mY = 0;
                        else mX = 0;
                    }
                }

                const mag = Math.sqrt(mX*mX+mY*mY);
                if (mag > 0) { 
                    const moveSpeed = player.speed * (isTouchDevice ? mag : 1); 
                    if (Math.abs(mX) > Math.abs(mY)) player.direction = mX < 0 ? 'left' : 'right'; 
                    else player.direction = mY < 0 ? 'behind' : 'front'; 
                    // Player uses general moveEntity (collides with walls and hazards)
                    moveEntity(player, (mX/mag)*moveSpeed, (mY/mag)*moveSpeed, dt); 
                    player.animationTimer += dt; 
                    if (player.animationTimer > 0.15) { 
                        player.animationFrame = player.animationFrame === 1 ? 2 : 1; 
                        player.animationTimer = 0; 
                    } 
                }
                // Clamp player position to canvas bounds, considering player radius
                player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
                player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));


                if (player.direction === 'front' || player.direction === 'behind') { player.currentImage = loadedImages[`player_${player.direction}${player.animationFrame}`]; } else { player.currentImage = loadedImages[`player_${player.direction}`]; }
                if (keys[' '] && player.shootCooldown <= 0) { shoot(); player.shootCooldown = 0.3; }

                if (player.invincibilityTimer <= 0) { for (const hazard of hazards) { const dist = Math.sqrt((player.x - hazard.x)**2 + (player.y - hazard.y)**2); if (dist < player.radius + hazard.radius) { handlePlayerDamage(); break; } } }
                
                vampires.forEach((v, i) => {
                    v.hurtTimer = Math.max(0, v.hurtTimer - dt); v.bobTimer += dt * 4;
                    const distToPlayer=Math.sqrt((player.x-v.x)**2+(player.y-v.y)**2);
                    if (distToPlayer < v.detectionRadius) { v.aiState = 'attacking'; v.shootCooldown -= dt; if (v.shootCooldown <= 0) { vampireShoot(v); v.shootCooldown = 0.8 + Math.random() * 0.7; } } else { v.aiState = 'wandering'; }
                    if(player.invincibilityTimer <= 0 && distToPlayer < player.radius+v.radius) { handlePlayerDamage(); if (player.health <= 0) { endGame(); return; } }
                    v.repathTimer -= dt;
                    if (v.repathTimer <= 0 || !v.path || v.path.length === 0) {
                        v.repathTimer = 1.5 + Math.random(); const start = {x:Math.floor(v.x/TILE_SIZE),y:Math.floor(v.y/TILE_SIZE)}; let end;
                        if (v.aiState === 'attacking') { end = {x:Math.floor(player.x/TILE_SIZE),y:Math.floor(player.y/TILE_SIZE)}; } else { if (!v.wanderTarget || (Math.floor(v.x/TILE_SIZE) === v.wanderTarget.x && Math.floor(v.y/TILE_SIZE) === v.wanderTarget.y)) { const randomTile = getEmptyTile(); v.wanderTarget = { x: Math.floor(randomTile.x/TILE_SIZE), y: Math.floor(randomTile.y/TILE_SIZE) }; } end = v.wanderTarget; }
                        v.path = findPath(start, end); // Pathfinding now respects hazards
                    }
                    if(v.path && v.path.length > 0){ 
                        const nextStep = v.path[0]; 
                        const tX = nextStep.x*TILE_SIZE+TILE_SIZE/2, tY = nextStep.y*TILE_SIZE+TILE_SIZE/2, 
                        dx = tX - v.x, dy = tY - v.y, dist = Math.sqrt(dx*dx+dy*dy); 
                        if (dist > 0.1) { 
                            if (Math.abs(dx) > Math.abs(dy)) v.direction = dx < 0 ? 'left' : 'right'; 
                            else v.direction = dy < 0 ? 'behind' : 'front'; 
                            // Vampires use general moveEntity (collides with walls and hazards)
                            moveEntity(v, (dx/dist)*v.speed, (dy/dist)*v.speed, dt); 
                        } 
                        if (Math.floor(v.x/TILE_SIZE)===nextStep.x && Math.floor(v.y/TILE_SIZE)===nextStep.y) v.path.shift(); 
                    }
                    const state = v.hurtTimer > 0 ? 'hurt' : 'run'; v.currentImage = loadedImages[`${v.spriteKey}_${state}_${v.direction}`];
                    for(let j=i+1;j<vampires.length;j++){ const o=vampires[j], vdx=o.x-v.x, vdy=o.y-v.y, vDist=Math.sqrt(vdx*vdx+vdy*vdy), min_dist=v.radius+o.radius; if(vDist<min_dist){ const overlap=(min_dist-vDist), pX=(vdx/vDist)*(overlap/2), pY=(vdy/vDist)*(overlap/2); v.x-=pX; v.y-=pY; o.x+=pX; o.y+=pY; } }
                });

                // Projectile collision with walls AND hazards
                for (let i = arrows.length-1; i >= 0; i--) { 
                    const a = arrows[i]; 
                    a.x += a.velX * dt; a.y += a.velY * dt; 
                    // Projectiles now collide with hazards too
                    if(isObstacle(a.x, a.y, a.radius)){arrows.splice(i, 1); continue;} 
                    if(player.invincibilityTimer <= 0 && Math.sqrt((a.x-player.x)**2+(a.y-player.y)**2)<a.radius+player.radius){ handlePlayerDamage(); arrows.splice(i,1); if(player.health <= 0) { endGame(); return; } break; } 
                }
                for (let i = bullets.length-1; i >= 0; i--) { 
                    const b = bullets[i]; 
                    b.x += b.velX * dt; b.y += b.velY * dt; 
                    // Projectiles now collide with hazards too
                    if(isObstacle(b.x, b.y, b.radius)){bullets.splice(i, 1); continue;} 
                    for(let j=vampires.length-1;j>=0;j--){ 
                        const v=vampires[j]; 
                        if(Math.sqrt((b.x-v.x)**2+(b.y-v.y)**2)<b.radius+v.radius){ 
                            v.health--; v.hurtTimer = 0.2; bullets.splice(i,1); 
                            if(v.health<=0){ 
                                switch(v.type){ 
                                    case'purple':score+=100;break; 
                                    case'orange':score+=150;break; 
                                    default:score+=50; 
                                } 
                                updateUI(); vampires.splice(j,1); 
                            } 
                            break; 
                        } 
                    } 
                }
                if (vampires.length === 0 && gameState === 'playing') { if (currentLevel < TOTAL_LEVELS) { overlays.levelComplete.classList.add('visible'); gameState = 'levelComplete'; } else { overlays.win.classList.add('visible'); gameState = 'win'; } }
            }
            function vampireShoot(v) { const dx = player.x - v.x; const dy = player.y - v.y; let dir = {x: 0, y: 0}; if (Math.abs(dx) > Math.abs(dy)) { dir.x = Math.sign(dx); } else { dir.y = Math.sign(dy); } if (dir.x !== 0 || dir.y !== 0) { arrows.push(createArrow(v.x, v.y, dir)); } }
            function handlePlayerDamage() { player.health--; player.invincibilityTimer = 1.5; updateUI(true); teleportPlayerToSafeLocation(); }
            function findPath(start, end) { const openSet = [], closedSet = new Set(); const heuristic = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y); const startNode = { x: start.x, y: start.y, g: 0, h: heuristic(start, end), f: 0, parent: null }; startNode.f = startNode.h; openSet.push(startNode); while (openSet.length > 0) { let current = openSet.reduce((a, b) => a.f < b.f ? a : b); if (current.x === end.x && current.y === end.y) { const path = []; let temp = current; while (temp && temp.parent) { path.unshift({ x: temp.x, y: temp.y }); temp = temp.parent; } return path; } openSet.splice(openSet.indexOf(current), 1); closedSet.add(`${current.x},${current.y}`); const neighbors = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}]; for (const { dx, dy } of neighbors) { const nX = current.x + dx, nY = current.y + dy; 
                // Changed: Pathfinding now uses isTileBlockedForPathfinding to go around walls AND hazards
                if (isTileBlockedForPathfinding(nX, nY) || closedSet.has(`${nX},${nY}`)) continue; 
                const gScore = current.g + 1; let neighborNode = openSet.find(node => node.x === nX && node.y === nY); if (!neighborNode) { neighborNode = { x: nX, y: nY, g: gScore, h: heuristic({ x: nX, y: nY }, end), parent: current }; neighborNode.f = neighborNode.g + neighborNode.h; openSet.push(neighborNode); } else if (gScore < neighborNode.g) { neighborNode.g = gScore; neighborNode.f = gScore + neighborNode.h; neighborNode.parent = current; } } } return []; }
            function draw() {
                ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#4a2a2a'; ctx.fillRect(0,0,canvas.width,canvas.height);
                if (maze) { for(let y=0;y<ROWS;y++){ for(let x=0;x<COLS;x++){ if(maze[y][x] === 1) { ctx.drawImage(loadedImages.wall, x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE); } } } }
                if (hazards) { hazards.forEach(h => { if (h.image) { const drawSize = h.radius * 2; ctx.drawImage(h.image, h.x - h.radius, h.y - h.radius, drawSize, drawSize); } }); }
                if(arrows){ctx.fillStyle='red';ctx.strokeStyle='#8B0000';ctx.lineWidth=2;arrows.forEach(a=>{ctx.save();ctx.translate(a.x,a.y);ctx.rotate(a.angle);ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(-a.radius, -a.radius/2);ctx.lineTo(-a.radius, a.radius/2);ctx.closePath();ctx.fill();ctx.stroke();ctx.restore();});}
                if(bullets){ctx.fillStyle='#2A52BE';ctx.strokeStyle='#ADD8E6';ctx.lineWidth=2;bullets.forEach(b=>{ctx.save();ctx.translate(b.x,b.y);ctx.rotate(b.angle);ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(-b.radius, -b.radius/2);ctx.lineTo(-b.radius, b.radius/2);ctx.closePath();ctx.fill();ctx.stroke();ctx.restore();});}
                if(vampires){ vampires.forEach(v=>{ if(v.currentImage){ const bobOffset = Math.sin(v.bobTimer) * v.bobAmount; ctx.save(); ctx.translate(v.x, v.y + bobOffset); if(v.spriteKey==='vampire3' && v.direction==='right') ctx.scale(-1,1); ctx.drawImage(v.currentImage, -VAMPIRE_SPRITE_SIZE/2, -VAMPIRE_SPRITE_SIZE/2, VAMPIRE_SPRITE_SIZE, VAMPIRE_SPRITE_SIZE); ctx.restore(); } }); }
                if(player){ if(player.currentImage){ctx.save();ctx.translate(player.x,player.y);ctx.drawImage(player.currentImage,-PLAYER_SPRITE_SIZE/2,-PLAYER_SPRITE_SIZE/2,PLAYER_SPRITE_SIZE,PLAYER_SPRITE_SIZE);ctx.restore();} if(player.invincibilityTimer>0){const pF=Math.abs(Math.sin(Date.now()*0.005));ctx.strokeStyle=`rgba(0,123,167,${0.5+pF*0.5})`;ctx.lineWidth=4;ctx.beginPath();ctx.arc(player.x,player.y,player.radius+3,0,Math.PI*2);ctx.stroke();} }
                
                if(gameState==='countdown' || gameState==='goDisplay'){
                    let displayValue;
                    if (gameState === 'countdown') {
                        displayValue = countdown > 0 ? countdown : ""; 
                    } else { // gameState === 'goDisplay'
                        displayValue = "GO!";
                    }
                    if (displayValue) { 
                        ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
                        ctx.font=`bold 150px ${getComputedStyle(document.documentElement).getPropertyValue('--font-gothic')}`;
                        ctx.textAlign="center";
                        ctx.textBaseline="middle";
                        ctx.strokeStyle="black";
                        ctx.lineWidth=6;
                        ctx.strokeText(displayValue,canvas.width/2,canvas.height/2);
                        ctx.fillText(displayValue,canvas.width/2,canvas.height/2);
                    }
                }
            }
            function gameLoop(t){ const dt=(t-lastTime)/1000; lastTime=t; if(dt>0&&dt<1)update(dt); draw(); requestAnimationFrame(gameLoop); }
            function resizeGame() { const gA=document.getElementById('game-area'),cW=document.getElementById('canvas-wrapper'),aW=gA.clientWidth,aH=gA.clientHeight,cAR=canvas.width/canvas.height;let nW=aW,nH=nW/cAR;if(nH>aH){nH=aH;nW=nH*cAR;}cW.style.width=`${nW}px`;cW.style.height=`${nH}px`;}
            
            function createHazardsFromMaze(grid) { const newHazards = []; for (let y = 0; y < ROWS; y++) { for (let x = 0; x < COLS; x++) { const tileType = grid[y][x]; if (tileType > 1) { const config = HAZARD_CONFIG[tileType]; if (config) { newHazards.push({ x: x * TILE_SIZE + TILE_SIZE / 2, y: y * TILE_SIZE + TILE_SIZE / 2, radius: config.radius, type: config.type, image: loadedImages[`hazard${config.type}`] }); } } } } return newHazards; }
            function generateLevelLayout() { 
                let nM=Array.from({length:ROWS},()=>Array(COLS).fill(0)); 
                for (let y=0;y<ROWS;y++) { for (let x=0;x<COLS;x++) { if (y===0||y===ROWS-1||x===0||x===COLS-1) nM[y][x]=1;}} 
                
                // Reverted: Changed hazard density to 15% of map tiles and ensure random types
                const numHazards=Math.floor(COLS*ROWS*0.15);
                for(let i=0;i<numHazards;i++){ 
                    const hx=Math.floor(Math.random()*(COLS-2))+1;
                    const hy=Math.floor(Math.random()*(ROWS-2))+1; 
                    // Ensure hazards don't spawn near player's initial spawn area (1.5, 1.5)
                    // and ensure they don't spawn on top of existing walls
                    if(nM[hy][hx]===0 && Math.sqrt((hx-1.5)**2+(hy-1.5)**2)>3) {
                        // Assign a random hazard type to each individual hazard
                        nM[hy][hx]=Math.floor(Math.random()*3)+2; 
                    }
                } 
                return nM; 
            }

            // Helper function to start the countdown
            function startCountdown() {
                countdown = 3;
                countdownTimer = 1;
                gameState = 'countdown';
                Object.values(overlays).forEach(o => o.classList.remove('visible')); // Hide any existing overlays
            }

            // Define enemy distribution for each level
            const levelEnemyDistribution = [
                // Level 0 is a placeholder for 1-based indexing convenience
                {red: 0, purple: 0, orange: 0}, 
                // L1-6: Introduce purple and orange while reducing reds. Total 6 enemies.
                {red: 6, purple: 0, orange: 0}, // L1
                {red: 5, purple: 1, orange: 0}, // L2
                {red: 4, purple: 2, orange: 0}, // L3
                {red: 3, purple: 2, orange: 1}, // L4 (first orange introduced)
                {red: 2, purple: 3, orange: 1}, // L5
                {red: 1, purple: 4, orange: 1}, // L6
                // L7-10: Reds are gone. Increase total enemies while adding more purples. Total up to 8.
                {red: 0, purple: 5, orange: 1}, // L7
                {red: 0, purple: 6, orange: 1}, // L8
                {red: 0, purple: 7, orange: 1}, // L9
                {red: 0, purple: 8, orange: 1}, // L10 (Max purple before orange transition)
                // L11-18: Eliminate purple vampires by replacing with orange. Total up to 9.
                {red: 0, purple: 7, orange: 2}, // L11 (first purple replaced by orange)
                {red: 0, purple: 6, orange: 3}, // L12
                {red: 0, purple: 5, orange: 4}, // L13
                {red: 0, purple: 4, orange: 5}, // L14
                {red: 0, purple: 3, orange: 6}, // L15
                {red: 0, purple: 2, orange: 7}, // L16
                {red: 0, purple: 1, orange: 8}, // L17
                {red: 0, purple: 0, orange: 9}, // L18 (all purples replaced by orange)
                // L19-20: Final levels, only orange vampires. Total up to 11.
                {red: 0, purple: 0, orange: 10},// L19
                {red: 0, purple: 0, orange: 11} // L20
            ];


            function setupLevel(level){
                currentLevel=level; maze=generateLevelLayout(); hazards = createHazardsFromMaze(maze); player=createPlayer(); 
                if (isObstacle(player.x, player.y, player.radius)) { teleportPlayerToSafeLocation(); }
                vampires=[]; bullets=[]; arrows=[];
                
                let enemyTypesToSpawn=[];
                
                // Get enemy counts for the current level from the distribution array
                const currentLevelEnemies = levelEnemyDistribution[Math.min(level, TOTAL_LEVELS)];
                const { red: numRed, purple: numPurple, orange: numOrange } = currentLevelEnemies;

                for(let i=0;i<numRed;i++) enemyTypesToSpawn.push('red');
                for(let i=0;i<numPurple;i++) enemyTypesToSpawn.push('purple');
                for(let i=0;i<numOrange;i++) enemyTypesToSpawn.push('orange');
                
                // Determine if a new enemy type is introduced for the "New Threat!" screen
                newEnemyToShow = null; 
                // Check if purple vampire is new for this level
                if (numPurple > 0 && !seenEnemies.has('purple')) {
                    newEnemyToShow = 'purple';
                }
                // Check if orange vampire is new for this level (prioritize purple if both new)
                if (numOrange > 0 && !seenEnemies.has('orange') && newEnemyToShow === null) {
                    newEnemyToShow = 'orange';
                }
                // Add all enemy types for current level to seen enemies set
                enemyTypesToSpawn.forEach(type => seenEnemies.add(type));
                
                // Special case for level 1 to only show 'red' if it was never seen
                if (level === 1) {
                    if (!seenEnemies.has('red')) {
                         newEnemyToShow = 'red'; // This case might not be strictly needed if 'red' is always initial
                    }
                    seenEnemies = new Set(['red']); // Reset seen enemies to only red for Level 1, to correctly introduce others later
                }


                // Clear previous overlays for starting new flow
                Object.values(overlays).forEach(o=>o.classList.remove('visible'));
                document.getElementById('status-bar').style.visibility='visible'; 
                updateUI();

                // Display new enemy screen BEFORE countdown if applicable
                // Only show for new types AND if it's not the initial 'red' (which is covered by how-to-play)
                if (newEnemyToShow && (newEnemyToShow !== 'red' || level > 1)) { 
                    const ed = { 
                        red: { title: "First Hunt: Red Vampire!", desc: "The basic foe. Takes 2 shots to defeat." }, // Added for completeness, but not triggered by current logic
                        purple: { title: "New Threat: Purple Vampire!", desc: "A faster and tougher adversary, requiring 3 shots to defeat." }, 
                        orange: { title: "New Menace: Orange Vampire!", desc: "The swiftest and strongest foe, demanding 4 shots to overcome." }
                    };
                    overlays.newEnemy.querySelector('h2').textContent = ed[newEnemyToShow].title; // Fixed: Target h2 directly
                    document.getElementById('new-enemy-desc').textContent = ed[newEnemyToShow].desc;
                    overlays.newEnemy.classList.add('visible');
                    gameState = 'newEnemyIntro'; // This state waits for player to click "Continue"
                } else {
                    // If no new enemy, or it's level 1, start countdown directly
                    startCountdown();
                }

                // Spawn vampires after determining if new enemy screen is needed
                enemyTypesToSpawn.forEach(type=>{ 
                    let spawnPos; 
                    let attempts = 0;
                    const maxAttempts = 100; // Prevent infinite loops
                    do { 
                        spawnPos = getEmptyTile(); 
                        attempts++;
                    } while (isObstacle(spawnPos.x, spawnPos.y, TILE_SIZE/3) || // Ensure initial spawn is not on a hazard
                             Math.sqrt((spawnPos.x - player.x)**2 + (spawnPos.y - player.y)**2) < MIN_PLAYER_SPAWN_DISTANCE && attempts < maxAttempts);
                    
                    if (attempts >= maxAttempts) {
                        console.warn("Could not find a safe spawn location for vampire after many attempts. Spawning anyway.");
                    }
                    vampires.push(createVampire(spawnPos.x,spawnPos.y,type)); 
                });
            }
            function init(){ 
                highScore=parseInt(localStorage.getItem('redmarkHighScore'))||0; 
                preloadAllImages().then(() => { setTimeout(() => { overlays.intro.classList.remove('visible'); overlays.howToPlay.classList.add('visible'); }, 4000); resizeGame(); initEventListeners(); requestAnimationFrame(gameLoop); }).catch(error => { console.error("Error preloading images:", error); alert("Failed to load game assets."); });
            }
            function initEventListeners() {
                window.addEventListener('resize',()=>resizeGame());
                document.getElementById('how-to-play-continue').addEventListener('click', () => { overlays.howToPlay.classList.remove('visible'); overlays.start.classList.add('visible'); gameState = 'startScreen'; });
                // Modified: After new enemy screen, now start the countdown
                document.getElementById('new-enemy-continue').addEventListener('click', () => { overlays.newEnemy.classList.remove('visible'); startCountdown(); });
                document.getElementById('start-game-button').addEventListener('click', ()=>setupLevel(1));
                document.getElementById('continue-button').addEventListener('click', ()=>setupLevel(1));
                document.getElementById('play-again-hs-button').addEventListener('click', ()=>setupLevel(1));
                document.getElementById('play-again-win-button').addEventListener('click', ()=>setupLevel(1));
                document.getElementById('next-level-button').addEventListener('click', ()=>{if(currentLevel<TOTAL_LEVELS)setupLevel(currentLevel+1);else{overlays.levelComplete.classList.remove('visible'); overlays.win.classList.add('visible'); gameState='win';}}); 
                document.getElementById('quit-button').addEventListener('click', ()=>{overlays.gameOver.classList.remove('visible');overlays.newHighScore.classList.remove('visible');overlays.quitConfirm.classList.add('visible');});
                document.getElementById('quit-no-button').addEventListener('click', ()=>{overlays.quitConfirm.classList.remove('visible');endGame(true);});
                document.getElementById('quit-yes-button').addEventListener('click', ()=>{overlays.quitConfirm.classList.remove('visible');overlays.start.classList.add('visible');gameState='startScreen';document.getElementById('status-bar').style.visibility='hidden';});
                window.addEventListener('keydown', (e)=>{if(e.key in keys){if(e.key===' '||e.key.startsWith('Arrow'))e.preventDefault();keys[e.key]=true;}});window.addEventListener('keyup',(e)=>{if(e.key in keys){keys[e.key]=false;}});
                
                const joystickNub = document.getElementById('joystick-nub');
                const joystickBase = document.getElementById('joystick-container');
                let baseRect;
                setTimeout(() => { baseRect = joystickBase.getBoundingClientRect() }, 100); 
                const nubRadius = joystickNub.offsetWidth / 2;
                const baseRadius = joystickBase.offsetWidth / 2;

                function handleJoystickStart(e) { e.preventDefault(); baseRect = joystickBase.getBoundingClientRect(); joystick.active = true; joystickNub.style.cursor = 'grabbing'; updateJoystick(e.touches[0]); }
                function handleJoystickMove(e) { if (joystick.active) { e.preventDefault(); updateJoystick(e.touches[0]); } }
                function handleJoystickEnd(e) { joystick.active = false; joystick.vectorX = 0; joystick.vectorY = 0; joystickNub.style.cursor = 'grab'; joystickNub.style.transform = `translate(0px, 0px)`; }
                function updateJoystick(touch) {
                    const x = touch.clientX - baseRect.left - baseRadius;
                    const y = touch.clientY - baseRect.top - baseRadius;
                    const distance = Math.min(baseRadius - nubRadius, Math.sqrt(x*x + y*y));
                    const angle = Math.atan2(y, x);
                    const nubX = distance * Math.cos(angle);
                    const nubY = distance * Math.sin(angle);
                    joystick.vectorX = nubX / (baseRadius - nubRadius);
                    joystick.vectorY = nubY / (baseRadius - nubRadius);
                    joystickNub.style.transform = `translate(${nubX}px, ${nubY}px)`;
                }
                joystickBase.addEventListener('touchstart', handleJoystickStart, {passive: false});
                document.addEventListener('touchmove', handleJoystickMove, {passive: false});
                document.addEventListener('touchend', handleJoystickEnd);
                document.addEventListener('touchcancel', handleJoystickEnd);

                document.getElementById('btn-shoot').addEventListener('touchstart',(e)=>{e.preventDefault();keys[' ']=true;},{passive:false});
                document.getElementById('btn-shoot').addEventListener('touchend',(e)=>{e.preventDefault();keys[' ']=false;},{passive:false});
            }
            function endGame(recoveringFromQuit=false){ if(!recoveringFromQuit) gameState='gameOver'; if(score>highScore){highScore=score;localStorage.setItem('redmarkHighScore',highScore);document.getElementById('new-highscore-text').textContent=score;overlays.newHighScore.classList.add('visible');} else{document.getElementById('final-score-text').textContent=`Score: ${score}`;overlays.gameOver.classList.add('visible');} }
            function shoot(){ let dir={x:0,y:0}; if(player.direction==='behind')dir.y=-1;else if(player.direction==='front')dir.y=1;else if(player.direction==='left')dir.x=-1;else if(player.direction==='right')dir.x=1; if(dir.x===0&&dir.y===0)dir.x=1; const mag=Math.sqrt(dir.x**2+dir.y**2);if(mag>0){dir.x/=mag;dir.y/=mag;} bullets.push(createBullet(player.x,player.y,dir)); }
            function updateUI(hit = false) { if(!player)return;status.level.textContent=currentLevel;status.score.textContent=score;status.highScore.textContent=highScore;status.health.innerHTML=''; for(let i=0;i<player.maxHealth;i++){ const hS=document.createElement('span'); if(i<player.health){hS.textContent='🖤';hS.className='heart pulsing';} else{if(hit&&i===player.health){hS.textContent='💀';}else{hS.textContent='🖤';}hS.className='heart lost';} status.health.appendChild(hS); } } // Modified this line to remove setTimeout
            init();
        });
    </script>
</body>
</html>
